package main

import (
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/dave/jennifer/jen"
)

const runtimeImport = "github.com/edison-moreland/SceneEngine/submsg/runtime/go"
const msgpackImport = "github.com/vmihailenco/msgpack/v5"

type goGen struct {
	j *jen.File
}

func newGoGen() codegen {
	j := jen.NewFile(goPackage)
	j.ImportName(runtimeImport, "submsg")
	j.PackageComment("Code generated by submsg; DO NOT EDIT.")

	return &goGen{j}
}

func (g *goGen) MsgIds(prefix string, messages []MsgDesc) {
	g.j.Const().DefsFunc(func(g *jen.Group) {
		for i, msg := range messages {
			g.Id(goMsgId(prefix, msg)).Qual(runtimeImport, "MsgId").Op("=").Lit(i)
		}
	})
}

func (g *goGen) Server(prefix string, messages []MsgDesc) {
	// Server interface
	serverInterfaceId := goId(true, prefix, "server")
	g.j.Type().Id(serverInterfaceId).InterfaceFunc(func(g *jen.Group) {
		for _, msg := range messages {
			g.Id(snakeToGoId(true, msg.Name)).
				Call(jen.Id("body").Id("[]byte")).
				Id("error")
		}
	})

	// Server router
	innerFunc := jen.Func().
		Params(
			jen.Id("id").Qual(runtimeImport, "MsgId"),
			jen.Id("body").Id("[]byte")).
		Error().
		Block(jen.Switch(jen.Id("id")).BlockFunc(func(g *jen.Group) {
			for _, msg := range messages {
				g.Case(
					jen.Id(goMsgId(prefix, msg)),
				).Block(
					jen.Return(
						jen.Id("s").
							Dot(snakeToGoId(true, msg.Name)).
							Call(jen.Id("body")),
					),
				)
			}

			g.Default().Block(
				jen.Return(jen.Qual(runtimeImport, "ErrMsgIdUnknown")),
			)

		}))

	g.j.Func().
		Id(goId(true, prefix, "router")).
		Params(jen.Id("s").Id(serverInterfaceId)).
		Qual(runtimeImport, "MsgReceiver").
		Block(jen.Return(innerFunc))
}

func (g *goGen) Client(prefix string, messages []MsgDesc) {
	// Client struct
	clientId := goId(true, prefix, "client")
	g.j.Type().Id(clientId).Struct(
		jen.Id("s").
			Qual(runtimeImport, "MsgSender"),
	)

	// New Client func
	newClientId := goId(true, "new", prefix, "client")
	g.j.Func().Id(newClientId).Params(
		jen.Id("s").
			Qual(runtimeImport, "MsgSender"),
	).Op("*").Id(clientId).Block(
		jen.Return(
			jen.Op("&").Id(clientId).Values(
				jen.Id("s").Op(":").Id("s"),
			),
		),
	)

	// Function for sending messages
	for _, msg := range messages {
		g.j.Func().Params(
			jen.Id("c").Op("*").Id(clientId),
		).Id(snakeToGoId(true, msg.Name)).Params(
			jen.Id("b").Id("[]byte"),
		).Block(
			jen.Id("c").
				Dot("s").
				Call(
					jen.Id(goMsgId(prefix, msg)),
					jen.Id("b"),
				),
		)
	}
}

func (g *goGen) Type(t TypeDesc) {
	switch t.Type {
	case "struct":
		g.emitStruct(t)
	case "one_of":
		g.emitOneOf(t)
	}
}

func (g *goGen) emitOneOf(t TypeDesc) {
	oneOfIdent := snakeToGoId(true, t.Name)
	g.j.Type().
		Id(oneOfIdent).
		Struct(jen.Id("OneOf").Any())

	// Initializer
	g.j.Func().
		Id(oneOfIdent + "From").
		Types(
			jen.Id("T").
				UnionFunc(func(g *jen.Group) {
					for _, v := range t.Members {
						g.Id(snakeToGoId(true, v))
					}
				})).
		Params(jen.Id("v").Id("T")).
		Id(oneOfIdent).
		Block(
			jen.Return(
				jen.Id(oneOfIdent).
					Values(
						jen.Id("OneOf").
							Op(":").
							Id("v"))))

	// Custom msgpack encoder
	g.j.Func().
		Params(
			jen.Id("o").
				Op("*").
				Id(oneOfIdent)).
		Id("EncodeMsgpack").
		Params(
			jen.Id("e").
				Op("*").
				Qual(msgpackImport, "Encoder")).
		Error().
		Block(
			jen.Var().Err().Error(),

			jen.Switch(jen.Id("o").
				Dot("OneOf").
				Dot("(type)")).
				BlockFunc(func(g *jen.Group) {
					for i, t := range t.Members {
						g.Case(jen.Id(snakeToGoId(true, t))).
							Block(
								jen.Err().
									Op("=").
									Id("e").
									Dot("EncodeUint8").
									Call(jen.Lit(i)))
					}
					g.Default().
						Block(
							jen.Err().
								Op("=").
								Qual(runtimeImport, "ErrUnknownOneOfField"))
				}),

			jen.If(jen.Err().Op("!=").Nil()).
				Block(jen.Return(jen.Err())),

			jen.Return(
				jen.Id("e").
					Dot("Encode").
					Call(
						jen.Id("o").
							Dot("OneOf"))))

	// Custom msgpack decoder
	g.j.Func().
		Params(
			jen.Id("o").
				Op("*").
				Id(oneOfIdent)).
		Id("DecodeMsgpack").
		Params(
			jen.Id("d").
				Op("*").
				Qual(msgpackImport, "Decoder")).
		Error().
		Block(
			jen.List(jen.Id("t"), jen.Err()).
				Op(":=").
				Id("d").
				Dot("DecodeUint8").
				Call(),

			jen.If(jen.Err().Op("!=").Nil()).
				Block(jen.Return(jen.Err())),

			jen.Switch(jen.Id("t")).
				BlockFunc(func(g *jen.Group) {
					for i, t := range t.Members {
						g.Case(jen.Lit(i)).
							Block(
								jen.Var().
									Id("v").
									Id(snakeToGoId(true, t)),

								jen.Err().
									Op("=").
									Id("d").
									Dot("Decode").
									Call(jen.Op("&").Id("v")),

								jen.Id("o").
									Dot("OneOf").
									Op("=").
									Id("v"))
					}
					g.Default().
						Block(
							jen.Err().
								Op("=").
								Qual(runtimeImport, "ErrUnknownOneOfField"))
				}),

			jen.Return(jen.Err()))

}

func (g *goGen) emitStruct(t TypeDesc) {
	g.j.Type().
		Id(snakeToGoId(true, t.Name)).
		StructFunc(func(g *jen.Group) {
			for fieldName, fieldType := range t.Fields {
				g.Id(snakeToGoId(true, fieldName)).Id(submsgTypeToGo(fieldType))
			}
		})
}

func (g *goGen) Done() error {
	return g.j.Save(goOutputFile)
}

func submsgTypeToGo(submsgType string) string {
	switch submsgType {
	case "String":
		return "string"
	case "Bool":
		return "bool"
	case "Int":
		return "int64"
	case "Uint":
		return "uint64"
	case "Float":
		return "float64"
	case "Byte":
		return "byte"
	default:
		return snakeToGoId(true, submsgType)
	}
}

func snakeToGoId(export bool, snake string) string {
	return goId(export, strings.Split(snake, "_")...)
}

func goMsgId(p string, msg MsgDesc) string {
	parts := append([]string{p, "msg"}, strings.Split(msg.Name, "_")...)

	return goId(true, parts...)
}

func goId(export bool, parts ...string) string {
	var sb strings.Builder
	for i, part := range parts {
		part = strings.ToLower(part)

		if !export && i == 0 {
			sb.WriteString(part)
			continue
		}

		firstLetter, size := utf8.DecodeRuneInString(part)
		sb.WriteRune(unicode.ToUpper(firstLetter))
		sb.WriteString(part[size:])
	}

	return sb.String()
}
