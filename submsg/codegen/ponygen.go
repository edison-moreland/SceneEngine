package main

import (
	"bytes"
	"embed"
	"fmt"
	"os"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

//go:embed pony_templates
var ponyTemplates embed.FS

type ponyGen struct {
	generatedCode *bytes.Buffer

	t *template.Template
}

type ponyMsgTemplateContext struct {
	Prefix   string
	Messages []MsgDesc
}

type ponyStructTemplateContext struct {
	Name       string
	Fields     map[string]string
	FieldCount int
}

type ponyOneOfTemplateContext struct {
	Name          string
	Members       []string
	MemberCount   int
	DefaultMember string
}

func newPonyGen() codegen {
	var b bytes.Buffer
	b.WriteString("// Code generated by submsg; DO NOT EDIT. \n")

	imports := []string{
		"msgpack",
		"buffered",
		"debug",
		"collections",
		"../../submsg/runtime/pony",
	}
	for _, i := range imports {
		b.WriteString("use \"")
		b.WriteString(i)
		b.WriteString("\" \n")
	}

	t := template.Must(template.
		New("ponygen").
		Funcs(map[string]any{
			"lower": strings.ToLower,
			"add": func(a, b int) int {
				return a + b
			},
			"capitalize": func(s string) string {
				var sb strings.Builder
				firstLetter, size := utf8.DecodeRuneInString(s)
				sb.WriteRune(unicode.ToUpper(firstLetter))
				sb.WriteString(s[size:])

				return sb.String()
			},
			"snakeToCamel": func(s string) string {
				var sb strings.Builder
				for i, part := range strings.Split(s, "_") {
					part = strings.ToLower(part)

					if i == 0 {
						sb.WriteString(part)
						continue
					}

					firstLetter, size := utf8.DecodeRuneInString(part)
					sb.WriteRune(unicode.ToUpper(firstLetter))
					sb.WriteString(part[size:])
				}

				return sb.String()
			},
			"ponyType": func(submsgType string) string {
				switch submsgType {
				case "String":
					return "String"
				case "Bool":
					return "Bool"
				case "Int":
					return "I64"
				case "Uint":
					return "U64"
				case "Float":
					return "F64"
				case "Byte":
					return "U8"
				default:
					if realType, ok := strings.CutPrefix(submsgType, "[]"); ok {
						return fmt.Sprintf("Array[%s]", snakeToGoId(true, realType))
					}

					return snakeToGoId(true, submsgType)
				}
			},
			"msgpack_decode": func(t string) string {
				switch t {
				case "String":
					return "str"
				case "Bool":
					return "bool"
				case "Int":
					return "i64"
				case "Uint":
					return "u64"
				case "Float":
					return "f64"
				case "Byte":
					return "u8"
				default:
					return "EEEERRRRROROROROR"
				}
			},
			"msgpack": func(t string) string {
				switch t {
				case "String":
					return "str_8"
				case "Bool":
					return "bool"
				case "Int":
					return "int_64"
				case "Uint":
					return "uint_64"
				case "Float":
					return "float_64"
				case "Byte":
					return "uint_8"
				default:
					return "EEEERRRRROROROROR"
				}
			},
			"zeroVal": func(t string) string {
				switch t {
				case "String":
					return "\"\""
				case "Bool":
					return "false"
				case "Int", "Uint", "Byte":
					return "0"
				case "Float":
					return "0.0"
				default:
					if realType, ok := strings.CutPrefix(t, "[]"); ok {
						return fmt.Sprintf("Array[%s]", snakeToGoId(true, realType))
					}

					return snakeToGoId(true, t) + ".zero()"
				}
			},
			"arrayType": func(t string) string {
				return snakeToGoId(true, strings.TrimPrefix(t, "[]"))
			},
			"isPrimitive": func(t string) bool {
				switch t {
				case "String", "Bool", "Int", "Uint", "Float", "Byte":
					return true
				default:
					return false
				}
			},
			"isArray": func(t string) bool {
				return strings.HasPrefix(t, "[]")
			},
		}).ParseFS(ponyTemplates, "pony_templates/*.tmpl"))

	return &ponyGen{
		generatedCode: &b,
		t:             t,
	}
}

func (p *ponyGen) tmpl(name string, context any) {
	err := p.t.ExecuteTemplate(p.generatedCode, name, context)

	if err != nil {
		panic(err)
	}

}

func (p *ponyGen) MsgIds(prefix string, messages []MsgDesc) {
	p.tmpl("msg_ids.tmpl", ponyMsgTemplateContext{
		Prefix:   prefix,
		Messages: messages,
	})
}

func (p *ponyGen) Server(prefix string, messages []MsgDesc) {
	p.tmpl("server.tmpl", ponyMsgTemplateContext{
		Prefix:   prefix,
		Messages: messages,
	})
}

func (p *ponyGen) Client(prefix string, messages []MsgDesc) {
	p.tmpl("client.tmpl", ponyMsgTemplateContext{
		Prefix:   prefix,
		Messages: messages,
	})
}

func (p *ponyGen) Type(t TypeDesc) {
	switch t.Type {
	case "struct":
		p.tmpl("struct.tmpl", ponyStructTemplateContext{
			Name:       t.Name,
			Fields:     t.Fields,
			FieldCount: len(t.Fields),
		})
	case "one_of":
		p.tmpl("one_of.tmpl", ponyOneOfTemplateContext{
			Name:          t.Name,
			Members:       t.Members,
			MemberCount:   len(t.Members),
			DefaultMember: t.Members[0],
		})
	}
}

func (p *ponyGen) Done() error {
	return os.WriteFile(ponyOutputFile, p.generatedCode.Bytes(), 0666)
}
